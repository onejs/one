---
title: FAQ
---

### Why Vite?

It feels light and simple, runs fast and is easy to customize. It tree shakes well, has tons of web features, and has best-in-class types, documentation, type-docs, RFCs and community. It also has a huge ecosystem and responsive team.

### Is this production ready?

Yes! Thanks to many web bug fixes, tests and improvements, and native landing [Metro mode](/docs/metro-mode), One is now generally production ready. See the [Status documentation](/docs/status) for more details.

### Does this use Metro?

One supports two modes: [Metro mode](/docs/metro-mode) (recommended) uses Metro for native builds with maximum compatibility, while Vite-only mode is more experimental but offers a unified bundler experience.

### How does this relate to Expo Router?

One started as a fork of [Expo Router](https://docs.expo.dev/router/introduction/) but has since diverged significantly. We aim to maintain API compatibility where possible.

### Why use One instead of Expo Router?

One runs on Vite, which is fast, light, and has a massive ecosystem with best-in-class TypeScript support. One achieves significantly higher Lighthouse scores thanks to [render modes](/docs/render-modes), optimized loading strategies, and proper code splitting - you can hit 100 on Lighthouse while sharing nearly all your code with native.

With render modes, you can choose SSG, SSR, or SPA on a per-page basis - Expo Router is SPA-only on web. One includes a [Hono-based production server](/docs/one-serve) out of the box and deploys to [Vercel or Cloudflare](/docs/guides-deployment) with a single config option.

One also adds [dev tools](/docs/dev-tools) (Alt+Space) with SEO preview, route debugging, loader timing, error tracking, and a source inspector. Plus [middleware](/docs/routing-middlewares) for request interception and auth, and [typed loaders](/docs/routing-loader) that run on the server and tree-shake out of client bundles.

Expo Router does have features One lacks, like `use dom` and RSC support. We encourage you to evaluate both and choose based on your needs.

### Will you support RSC?

No, we find the complexity trade-off not worth it. One supports [SSG, SPA, and SSR](/docs/render-modes) with [loaders](/docs/routing-loader), and we recommend pairing with a sync engine like [Zero](https://zerosync.dev) for data. A simplified one-way RSC could work, which we'll continue to evaluate.

### What platforms does One support?

macOS (stable), Linux (developing), and Windows (early). See the [Status documentation](/docs/status) for details.

### Can I use One for web-only or native-only projects?

Yes. One works great as a web-only framework - you don't even need `react-native` as a dependency. For native-only, you can skip web-specific features like SSG/SSR. One is designed to be flexible whether you're targeting one platform or both.

### How does One compare to Next.js?

One takes a simpler approach: no RSC, no complex server/client boundaries. Instead, One uses [loaders](/docs/routing-loader) for data fetching (similar to Remix) and recommends pairing with a sync engine like [Zero](https://zerosync.dev) for real-time data. One also targets React Native alongside web with a single codebase, which Next.js doesn't support.

That said, One provides many things out of the box: [image optimization](/docs/guides-images) with blur placeholders, [dynamic OpenGraph images](/docs/guides-open-graph), [middleware](/docs/routing-middlewares), [automatic sitemaps](/docs/configuration#sitemap), [dev tools](/docs/dev-tools), a [production Hono server](/docs/one-serve), [API routes](/docs/render-modes#api), typed routes, scroll restoration, and a loading progress bar. See [Features](/docs/features) for the full list.

### How does One compare to TanStack Start?

Both are modern Vite-based frameworks with type safety and flexible rendering. One uses file suffixes (`page+ssg.tsx`, `page+ssr.tsx`) to set render modes while TanStack uses route property configuration. One also supports a global `defaultRenderMode`.

In One, SSG routes run loaders at build time and output static HTML. TanStack's "static prerendering" is a post-build crawl - a different model. One includes a [Hono server](/docs/one-serve) out of the box while TanStack Start requires setting up Nitro or deploying to specific platforms. One's loaders run on the server and tree-shake out of client bundles, while TanStack's loaders are isomorphic (run on server, then again on client during navigation). And One targets web and native with shared routes and loaders - TanStack Start is web-only.

Both are great choices for web - One is the better fit if you need cross-platform or prefer the simpler file-based approach.

### What's the difference between SSG, SSR, and SPA?

SSG (Static Site Generation) pre-renders pages at build time - fast and cacheable, ideal for mostly-static content. SSR (Server Side Rendering) renders on each request - good for dynamic content that needs SEO. SPA (Single Page Application) renders entirely on the client - simpler for highly dynamic dashboards. See [Render Modes](/docs/render-modes) for details.

### Can I use my existing React Native libraries?

Yes. With [Metro mode](/docs/metro-mode) (recommended), you get full compatibility with the React Native ecosystem. For libraries that have issues with Vite, One provides a [`deps` patching system](/docs/configuration#deps) to fix common problems like Flow types or JSX in `.js` files.

### How do I deploy a One app?

One includes a [Hono server](/docs/one-serve) out of the box - just run `one build && one serve`. You can also deploy to [Vercel or Cloudflare](/docs/guides-deployment) with a single config option.

### What's the npm package?

It's `one`, thanks to Dan Maier.

### Can I develop iOS apps on Windows or Linux?

Yes. With [EAS Build](https://docs.expo.dev/build/introduction/), you can build iOS apps in the cloud from any platform. For local development, you can test on Android and web, then build iOS when ready. See [Build or Run iOS](/docs/guides-ios-native) for details.

### What's the bundle size overhead?

One itself adds some overhead, but not enough to affect Lighthouse scores in general.

The core routing and rendering logic is under 20KB gzipped, but it brings in React Navigation and generally `react-native-web`. You can swap for `@tamagui/react-native-web-lite` using an alias to save quite a bit of bundle size.

### Can I use One with an existing React Native app?

Yes. One can be added incrementally to existing React Native projects. Start by installing `one` and setting up file-based routing alongside your existing navigation. [Metro mode](/docs/metro-mode) ensures compatibility with your current native setup.

### Does One support monorepos?

Yes. One works well in monorepos with tools like Turborepo, Nx, or pnpm workspaces. Configure your workspace's package resolution and One will respect it. The [one-recommended](https://github.com/onejs/one/tree/main/examples/one-recommended) example shows a typical setup.
