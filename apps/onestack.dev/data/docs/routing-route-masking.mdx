---
title: Route Masking
---

Route masking displays a different URL in the browser than the actual route being rendered. This is useful for creating modal experiences where you want a clean, shareable URL while still rendering a nested route.

For example, you might navigate to `/photos/5/modal` to show a photo in a modal overlay, but display `/photos/5` in the browser URL bar. When the user shares that URL or refreshes the page, you control what happens.

## Why Use Route Masking?

Common use cases include:

- **Modal overlays**: Show a photo modal at `/photos/[id]/modal` but display `/photos/[id]` in the URL
- **Preview panels**: Open a preview slide-over without changing the visible URL
- **Multi-step forms**: Navigate through form steps internally while keeping a clean URL

## Basic Setup

Route masks are configured using `setRouteMasks` and `createRouteMask`:

```tsx fileName=app/_layout.tsx
import { setRouteMasks, createRouteMask, Slot } from 'one'

// Configure route masks at the app root
setRouteMasks([
  createRouteMask({
    from: '/photos/[id]/modal',
    to: '/photos/[id]',
    params: true,
  }),
])

export default function Layout() {
  return <Slot />
}
```

Now when you navigate to `/photos/5/modal`, the browser URL shows `/photos/5`, but the modal route renders.

## Route Mask Options

The `createRouteMask` function accepts the following options:

### from

The route pattern to match (the actual route being navigated to). Supports dynamic segments.

```tsx
createRouteMask({
  from: '/photos/[id]/modal',
  // ...
})
```

### to

The route pattern to display in the browser URL (the masked URL). Dynamic segments are populated from the matched params.

```tsx
createRouteMask({
  from: '/photos/[id]/modal',
  to: '/photos/[id]',
  // ...
})
```

### params

Controls how parameters are forwarded to the masked URL:

- `true` (default): Forward all matched params
- `false`: Don't forward any params
- Function: Custom param transformation

```tsx
// Forward all params (default)
createRouteMask({
  from: '/users/[userId]/settings/[tab]',
  to: '/users/[userId]',
  params: true,
})

// Custom transformation
createRouteMask({
  from: '/products/[category]/[id]/edit',
  to: '/products/[category]',
  params: (matched) => ({
    category: matched.category,
    // Don't include id in the masked URL
  }),
})
```

### unmaskOnReload

Controls what happens when the user refreshes the page or navigates directly to the masked URL:

- `false` (default): Keep showing the actual route content (the modal)
- `true`: Show the masked URL's content instead

```tsx
// SPA-style: Refresh restores the modal
createRouteMask({
  from: '/photos/[id]/modal',
  to: '/photos/[id]',
  unmaskOnReload: false,
})

// Share-friendly: Refresh shows the photo detail page
createRouteMask({
  from: '/photos/[id]/modal',
  to: '/photos/[id]',
  unmaskOnReload: true,
})
```

## Complete Example

Here's a full example with a photo gallery that opens photos in a modal:

<RouteTree
  routes={[
    { name: '_layout.tsx', description: 'Root layout with route mask config' },
    { name: 'photos', children: [
      { name: '_layout.tsx', description: 'Photo grid layout' },
      { name: 'index.tsx', description: 'Photo list (empty, grid is in layout)' },
      { name: '[id]', children: [
        { name: 'index.tsx', description: 'Photo detail page - /photos/[id]' },
        { name: 'modal.tsx', description: 'Photo modal - /photos/[id]/modal' },
      ] },
    ] },
  ]}
/>

### Root Layout

```tsx fileName=app/_layout.tsx
import { setRouteMasks, createRouteMask, Slot } from 'one'

setRouteMasks([
  createRouteMask({
    from: '/photos/[id]/modal',
    to: '/photos/[id]',
    params: true,
    unmaskOnReload: false,
  }),
])

export default function RootLayout() {
  return (
    <html>
      <body>
        <Slot />
      </body>
    </html>
  )
}
```

### Photos Layout

```tsx fileName=app/photos/_layout.tsx
import { Link, Slot } from 'one'

const photos = [
  { id: '1', title: 'Photo 1' },
  { id: '2', title: 'Photo 2' },
  { id: '3', title: 'Photo 3' },
]

export default function PhotosLayout() {
  return (
    <div>
      <h1>Photos</h1>
      <div style={{ display: 'grid', gridTemplateColumns: 'repeat(3, 1fr)', gap: 16 }}>
        {photos.map((photo) => (
          <Link key={photo.id} href={`/photos/${photo.id}/modal`}>
            {photo.title}
          </Link>
        ))}
      </div>

      {/* Modal renders here via Slot */}
      <Slot />
    </div>
  )
}
```

### Photo Modal

```tsx fileName=app/photos/[id]/modal.tsx
import { useParams, useRouter } from 'one'

export default function PhotoModal() {
  const { id } = useParams<{ id: string }>()
  const router = useRouter()

  const handleClose = () => {
    router.navigate('/photos')
  }

  return (
    <div className="modal-overlay" onClick={handleClose}>
      <div className="modal-content" onClick={(e) => e.stopPropagation()}>
        <h2>Photo {id}</h2>
        <img src={`/images/photo-${id}.jpg`} alt={`Photo ${id}`} />
        <button onClick={handleClose}>Close</button>
      </div>
    </div>
  )
}
```

### Photo Detail Page

```tsx fileName=app/photos/[id]/index.tsx
import { useParams, Link } from 'one'

export default function PhotoDetail() {
  const { id } = useParams<{ id: string }>()

  return (
    <div>
      <h1>Photo {id}</h1>
      <img src={`/images/photo-${id}.jpg`} alt={`Photo ${id}`} />
      <Link href="/photos">Back to gallery</Link>
    </div>
  )
}
```

## How It Works

Route masking uses the browser's `history.state` to store the actual route path. When you navigate to a masked route:

1. One detects the route matches a mask pattern
2. The browser URL is updated to show the masked URL
3. The actual route path is stored in `history.state`
4. The actual route component renders

On page refresh:

- If `unmaskOnReload: false`: One reads the actual path from `history.state` and restores it
- If `unmaskOnReload: true`: One navigates to what the URL shows (the masked URL)

## Tips

- Configure route masks in your root `_layout.tsx` so they're available for all navigation
- Use `unmaskOnReload: true` when the masked URL should be shareable as a standalone page
- Use `unmaskOnReload: false` when you want to preserve the exact app state on refresh
- Route masks work with dynamic segments like `[id]` and catch-all segments like `[...rest]`
