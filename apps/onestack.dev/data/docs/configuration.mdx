---
title: Configuration
---

One is entirely configured through a Vite plugin:

```tsx fileName=vite.config.ts
import type { UserConfig } from 'vite'
import { one } from 'one/vite'

export default {
  plugins: [
    one({
      // all web-specific configuration nests in web:
      web: {
        // Choose the default strategy for routes without path-specifiers to render in
        // can be one of "spa", "ssg" or "ssr"
        defaultRenderMode: 'spa', // defaults to 'ssg'

        // If using a server-rendered render mode, looseHydration will collapse large hydration
        // error logs in development mode. React can gracefully recover from hydration issues,
        // and they can often be ignored, but by default React produces large error logs.
        // Turning this on will collapse those logs to one line.
        looseHydration: false, // defaults to true

        // Define server redirects for development and production
        redirects: [
          {
            source: '/vite',
            destination: 'https://vxrn.dev',
            permanent: true,
          },
          {
            source: '/docs/components/:slug/:version',
            destination: '/ui/:slug/:version',
            permanent: true,
          },
        ],

        // Configure production server compatibility (default node)
        // Options: 'node' or 'vercel'
        deploy: 'node',
      },

      /**
       * Path to a js or ts file to import before the rest of your app runs
       * One controls your root, but you may want to run some JS before anything else
       * Use this to give One the entrypoint to run
       */
      setupFile: './setup.ts',

      router: {
        /**
         * An array of globs that One uses to ignore files in your routes directory. If a file matches any pattern, it will not be treated as a route.
         *
         * This is useful for ignoring test or utility files you wish to colocate.
         */
        ignoredRouteFiles: ['**/*.test.*'],
      },

      optimization: {
        /**
         * By default One scans your fs routes and adds them as Vite `entries`, this prevents some hard
         * reloads on web as you navigate to new pages, but can slow things startup.
         *
         * The 'flat' option is default and will automatically add just the routes at the root of your
         * app but nothing nested in non-group folders below that.
         *
         * @default 'flat'
         */
        autoEntriesScanning?: boolean | 'flat'
      },

      // native-specific config:
      native: {
        // One will set up your React Native app to run via AppRegistry.registerComponent(app.key)
        // This setting determines app.key and must match the React Native app container you've built
        key: 'AppName',

        // Choose the bundler for native builds
        // - 'metro' is recommended for production stability.
        // - 'vite' is experimental but offers faster builds with SWC.
        bundler: 'metro', // defaults to 'vite'
      },

      config: {
        // Disable or configure the auto-added vite-tsconfig-paths
        // https://www.npmjs.com/package/vite-tsconfig-paths
        tsConfigPaths: false,

        // Disable auto-adding default tsconfig.json if not found
        ensureTSConfig: false,
      },

      react: {
        // Enable react compiler (default false)
        compiler: true,
      },

      // The deps configuration is a powerful way to apply patches to node_modules
      // to configure patching and optimizeDeps for server-side.
      // we found the React Native and general node module package ecosystem to not always
      // play nice with universal apps, and this provides an easy way to configure them
      deps: {
        'moti/author': true,
        '@sentry/react-native': {
          version: '~15.2.0',
          '**/*.js': ['jsx'],
        },
      },

      /**
       * Per-file control over how code transforms.
       * Defaults to SWC, runs babel before SWC if:
       *
       *  - options.react.compiler is `true`, on tsx files in your app
       *  - `react-native-reanimated` is in your dependencies and a file contains a reanimated keyword
       *
       * Otherwise One defaults to using `@swc/core`.
       *
       * Accepts a function:
       *
       *   (props: {
       *      id: string
       *      code: string
       *      development: boolean
       *      environment: Environment
       *      reactForRNVersion: '18' | '19'
       *   }) =>
       *      | true     // default transforms
       *      | false    // no transforms
       *      | 'babel'  // force babel default transform
       *      | 'swc'    // force swc default transform
       *
       *       // force babel, custom transform
       *
       *      | {
       *          transform: 'babel'
       *          excludeDefaultPlugins?: boolean
       *        } & babel.TransformOptions
       *
       *      // force swc, custom transform
       *
       *      | {
       *          transform: 'swc'
       *        } & SWCOptions
       *
       * Babel defaults to preset `@babel/preset-typescript` with plugins:
       *
       *  - @babel/plugin-transform-destructuring
       *  - @babel/plugin-transform-runtime
       *  - @babel/plugin-transform-react-jsx
       *  - @babel/plugin-transform-async-generator-functions
       *  - @babel/plugin-transform-async-to-generator
       *
       *
       * SWC default to target es5 for native, es2020 for web.
       *
       */
      transform: true,
    }),
  ],
} satisfies UserConfig
```

Note that some of this configuration is ultimately stored into [environment variables](/docs/environment) automatically, accessible in your apps and website. For TypeScript support, add `/// <reference types="one/env" />` to get typed access to these variables.

## setupFile

Path to a JS or TS file to import before the rest of your app runs. One controls your root component, but you may want to run some initialization code before anything else.

```tsx fileName=vite.config.ts
export default {
  plugins: [
    one({
      // Single file for all environments
      setupFile: './setup.ts',

      // Or different files per environment
      setupFile: {
        client: './setup.client.ts',
        server: './setup.server.ts',
        native: './setup.native.ts',
      },

      // Or with platform-specific native files
      setupFile: {
        client: './setup.client.ts',
        server: './setup.server.ts',
        ios: './setup.ios.ts',
        android: './setup.android.ts',
      },
    }),
  ],
}
```

## native

The native object allows you to configure your native apps.

### native.key

One will set up your React Native app to run via `AppRegistry.registerComponent(app.key)`.

This setting must match the key you gave the React Native app container you've built.

### native.bundler

Choose the bundler for native builds. Options are:

- `'metro'` (recommended): Uses the standard React Native Metro bundler for maximum stability and compatibility
- `'vite'` (experimental): Uses Vite for native bundling with faster builds via SWC

**We strongly recommend using Metro mode for production applications** as it provides:

- Full compatibility with all React Native packages
- Battle-tested stability
- Standard React Native bundling behavior

For detailed information including limitations, configuration options, and performance considerations, see the [Metro Mode documentation](/docs/metro-mode).

### native.css

Enables [react-native-css-interop](https://github.com/marklawlor/nativewind) support when importing CSS on native. This allows you to use CSS imports in your React Native code.

```tsx fileName=vite.config.ts
export default {
  plugins: [
    one({
      native: {
        css: true,
      },
    }),
  ],
}
```

**Default:** `false`

## web

The web object allows you to configure web specific settings.

### web.defaultRenderMode

Choose between one of `ssg`, `spa` or `ssr`. The default is `ssg`.

Each mode has trade-offs:

- `ssg` stands for "Static Site Generated", it is the default mode.

SSG is a great general purpose strategy, where your pages are rendered fully at build-time and turned into static HTML. This means you can get a "perfect" first load, where your app is fully rendered with all content, servable easily by a CDN.

The JS is sent alongside it, and React will hydrate your app and resume running from there. The downside is that you do have some complexity in needing to ensure your pages can render in node, the upside is increased performance and SEO on the web.

- `spa` stands for "Single Page App", which is the simplest strategy.

SPA mode will not render the page on the server at all, and instead only serve the JavaScript to render your page
to the users browser. This mode avoids some complexity - you don't have to make your React code

- `ssr` stands for "Sever Side Rendered".

This mode will render your page on the server at the time the browser requests it, running loaders as well for each request.

This mode is likely the least useful, as it means that you must make a full trip to your database at the time of each request, and your client is left waiting for the full render from the server before it can show anything. That said, this mode can be useful if you have dynamically generated content but still want to have the best possible SEO, at the cost of some complexity in supporting server rendering.

### redirects

You can apply server-level redirects. One serves your app with Hono in production, and so the redirect pattern is simple: your `source` will be passed to `Hono.app.get(source)`. Any matching path segments that start with `:` will be replaced into the matching segments in `destination`. And the redirect will send a response type of `301` if permanent is true, otherwise it will be `302`.

### web.linkPrefetch

Controls link prefetching strategy for improved navigation performance.

```tsx fileName=vite.config.ts
export default {
  plugins: [
    one({
      web: {
        // Smart trajectory-based prefetching (default)
        linkPrefetch: 'intent',

        // Or choose a simpler strategy
        linkPrefetch: 'viewport', // prefetch when links enter viewport
        linkPrefetch: 'hover', // prefetch on mouseover only
        linkPrefetch: false, // disable prefetching
      },
    }),
  ],
}
```

**Options:**

- **`'intent'`** (default): Uses mouse trajectory prediction to prefetch links before you hover them. Ray-casting detects when you're moving toward a link, with winner-takes-all scoring to avoid over-fetching in dense navigation areas. Falls back to hover for immediate interactions.

- **`'viewport'`**: Prefetches links when they enter the viewport (with 100px margin). Good for content-heavy pages with many links.

- **`'hover'`**: Traditional hover-based prefetching. Prefetches when you mouseover a link.

- **`false`**: Disables link prefetching entirely.

### web.deploy

Deployment target for production builds. Determines how the server bundle is built.

```tsx fileName=vite.config.ts
export default {
  plugins: [
    one({
      web: {
        deploy: 'vercel', // or 'node' or 'cloudflare'
      },
    }),
  ],
}
```

**Options:**

- **`'node'`** (default): Standard Node.js server using Hono
- **`'vercel'`**: Vercel serverless functions
- **`'cloudflare'`**: Cloudflare Workers

### web.inlineLayoutCSS

When enabled, inlines CSS content directly into the HTML instead of using `<link>` tags. This eliminates an extra network request for CSS, improving LCP (Largest Contentful Paint) scores.

```tsx fileName=vite.config.ts
export default {
  plugins: [
    one({
      web: {
        inlineLayoutCSS: true,
      },
    }),
  ],
}
```

This is particularly effective for layout CSS that's critical for the initial render. Combined with `experimental_scriptLoading`, you can achieve significant Lighthouse score improvements.

**Default:** `false`

### web.experimental_scriptLoading

Controls how scripts are loaded for improved performance. This is an experimental feature that can significantly improve Lighthouse scores by deferring non-critical JavaScript.

```tsx fileName=vite.config.ts
export default {
  plugins: [
    one({
      web: {
        experimental_scriptLoading: 'after-lcp',
      },
    }),
  ],
}
```

**Options:**

- **`'defer-non-critical'`**: Critical scripts (framework entry, page, layouts) load immediately. Non-critical scripts (component imports, utilities) become modulepreload hints only, reducing network/CPU contention.

- **`'after-lcp'`**: Scripts download immediately via modulepreload but execution is deferred until after first paint using double requestAnimationFrame. This allows the browser to paint the SSR content before executing JavaScript. Only applies to SSG pages.

- **`'after-lcp-aggressive'`**: Only modulepreloads critical scripts (entry, layouts). Non-critical scripts have no modulepreload hints, reducing network saturation. Best for pages with many chunks or slow networks.

**Default:** `undefined` (all scripts load with async)

### web.sitemap

Generate a `sitemap.xml` file automatically during build. This helps search engines discover and index your pages.

```tsx fileName=vite.config.ts
export default {
  plugins: [
    one({
      web: {
        // Simple: just enable it
        sitemap: true,

        // Or configure it
        sitemap: {
          // Base URL for sitemap entries (defaults to ONE_SERVER_URL env var)
          baseUrl: 'https://example.com',

          // Default priority for all routes (0.0 to 1.0)
          priority: 0.7,

          // Default change frequency
          changefreq: 'weekly',

          // Glob patterns for routes to exclude
          exclude: ['/admin/*', '/internal/*'],
        },
      },
    }),
  ],
}
```

The sitemap automatically:

- Includes all page routes (SSG, SPA, SSR)
- Expands dynamic routes using their `generateStaticParams` output
- Excludes API routes and not-found pages

**Route-level overrides:** Routes can export a `sitemap` object to customize their entry. See [Routing Exports](/docs/routing-exports#sitemap) for details.

**Base URL:** If `baseUrl` isn't specified, One uses the `ONE_SERVER_URL` environment variable. If neither is set, paths are relative.

### web.renderRootLayout

Renders the root `_layout` into the HTML shell for SPA pages, giving users immediate visual content (nav, sidebar, head tags, CSS) while page-level content remains client-rendered.

Without this option, SPA pages ship a completely empty `<body>` and nothing is visible until JavaScript downloads and executes. With `renderRootLayout`, the root layout's HTML is included in the initial response so users see your app chrome immediately.

```tsx fileName=vite.config.ts
export default {
  plugins: [
    one({
      web: {
        renderRootLayout: 'always-static',
      },
    }),
  ],
}
```

**Options:**

- **`'always-static'`**: Root layout is rendered once at build time (SSG-style). The resulting HTML shell is served statically for all SPA pages. No layout loaders are run.

- **`'always-ssr'`**: Root layout is rendered per-request on the server. This supports layout loaders (e.g., auth state in your nav), but page content is still client-only.

- **`'static-or-ssr'`**: Static HTML shell at build time, with SSR at runtime for layout loaders. Combines the benefits of both modes.

SSG and SSR pages already render the full layout, so this option only affects SPA page behavior. The root layout has no dynamic route params (it's always at `/`), making it a safe candidate for rendering independent of the page's render mode.

**How it works:**

The server renders your root `_layout` component into the HTML, with a `<div data-one-spa-content="">` placeholder where page content would go. After JavaScript loads and hydrates the shell, the placeholder is replaced with your real page content.

**Default:** `undefined` (SPA pages ship with an empty body, existing behavior)

## react

### react.compiler

Enables the new [React Compiler](https://react.dev/learn/react-compiler) for both native and web. Will slow down compilation as it uses Babel, but will improve app performance and reduce the need to write memoization.

```tsx fileName=vite.config.ts
export default {
  plugins: [
    one({
      react: {
        compiler: true, // enable for all platforms
        // or
        compiler: 'web', // enable only for web
        // or
        compiler: 'native', // enable only for native
      },
    }),
  ],
}
```

**Default:** `false`

## optimization

Performance optimization options.

### optimization.autoEntriesScanning

By default, One scans your file system routes and adds them as Vite `entries`. This prevents some hard reloads on web as you navigate to new pages, but can slow down startup.

```tsx fileName=vite.config.ts
export default {
  plugins: [
    one({
      optimization: {
        autoEntriesScanning: 'flat', // only root-level routes (default)
        // or
        autoEntriesScanning: true, // scan all routes
        // or
        autoEntriesScanning: false, // disable scanning
      },
    }),
  ],
}
```

**Options:**

- **`'flat'`** (default): Automatically adds just the routes at the root of your app but nothing nested in non-group folders below that
- **`true`**: Scans and adds all routes as entries
- **`false`**: Disables auto-scanning entirely

## devtools

Development tools to help debug and understand your app. Enabled by default in development mode.

```tsx fileName=vite.config.ts
export default {
  plugins: [
    one({
      // Enable all devtools (default)
      devtools: true,

      // Disable all devtools
      devtools: false,

      // Configure individual tools
      devtools: {
        inspector: true, // enabled by default
        seoPreview: true, // enabled by default
      },
    }),
  ],
}
```

### devtools.inspector

The source inspector lets you quickly find the source code for any element on the page:

1. Hold **Shift+Cmd** (Mac) or **Shift+Ctrl** (Windows/Linux)
2. Hover over any element to see its source file location
3. Click to open the file in your editor

This works automatically without any additional setup - One injects the necessary data attributes during development and handles opening files in your configured editor.

### devtools.seoPreview

The SEO Preview panel helps you visualize how your pages will appear in search results and social media shares:

1. Press **Alt+S** to toggle the panel
2. View previews for:
   - **Google Search** - How your page appears in search results
   - **Open Graph** - How your page appears when shared on Facebook, LinkedIn, etc.
   - **Twitter Card** - How your page appears when shared on Twitter/X
3. See all meta tags at a glance with validation warnings for common SEO issues

The panel automatically updates as you navigate or modify meta tags, making it easy to verify your SEO configuration during development.

### devtools.routeDebug

The Route Debug panel helps you understand your current route state during development:

1. Press **Alt+R** to toggle the panel
2. View information about the current route:
   - **Pathname** - The current URL path
   - **Segments** - Breadcrumb-style view of path segments
   - **Route Params** - Dynamic route parameters (e.g., `[slug]`, `[id]`)
   - **Search Params** - Query string parameters
   - **Hash** - URL fragment (if present)
   - **Full URL** - Complete URL for reference

The panel updates automatically as you navigate, making it easy to debug routing issues and verify params are being parsed correctly.

### devtools.loaderTiming

The Loader Timing Waterfall panel shows performance metrics for your route loaders:

1. Press **Alt+L** to toggle the panel
2. View timing data for each loader:
   - **Module Load Time** (blue) - Time to download and parse the loader module
   - **Execution Time** (green) - Time for the loader function to complete
   - **Total Time** - End-to-end timing
   - **Source** - Whether this was an initial load, refetch, or preload
3. Visual waterfall shows relative timing of module load vs execution
4. Error states are highlighted with red indicators

The panel helps identify slow loaders and understand where time is being spent - whether in module loading (suggesting code splitting issues) or execution (suggesting slow data fetching).

### devtools.routePreload

The Route Preload panel shows which routes have been preloaded during navigation:

1. Press **Alt+P** to toggle the panel
2. View preloaded routes with status:
   - **Loading** - Preload in progress
   - **Loaded** - Successfully preloaded (shows duration, loader/CSS status)
   - **Error** - Preload failed (shows error message)

**Note:** Route preloading only works in production builds. In development, the panel shows a notice explaining this. Run `yarn build && yarn serve` to test preloading behavior.

Preloading is automatically triggered when users hover over links, warming the cache for likely navigation targets.

### devtools.errorPanel

The Error Panel shows errors caught by error boundaries and loaders during development:

1. Press **Alt+E** to toggle the panel
2. View error history with:
   - **Error Type** - Whether from render, loader, or hydration
   - **Route** - The route where the error occurred
   - **Error Message** - The error message with expandable stack trace
   - **Timestamp** - When the error occurred

The panel automatically appears when the first error is caught, making it easy to spot issues immediately. Click "Clear" to reset the error history. Error boundaries and loaders dispatch events that the panel listens to, giving you a unified view of all errors in your app.

## deps

While building One we found ourselves needing to apply small patches to a variety of packages. Packages in the React Native ecosystem are often published only for Metro, and so have a variety of weird setups.

We built an internal Vite plugin to easily apply patches across any package manager, but after installing One into a few larger production projects, we found ourselves wanting to have access to it.

The `deps` option is a powerful way to coerce your node_modules to be compatible with Vite.

Here's an example:

```tsx fileName=vite.config.ts
import type { UserConfig } from 'vite'
import { one } from 'one/vite'

export default {
  plugins: [
    one({
      deps: {
        // setting to true is the same as setting:
        // viteConfig.ssr.optimizeDeps.include.push('moti/author')
        'moti/author': true,

        // setting to 'interop' is the same as setting:
        // viteConfig.ssr.optimizeDeps.include.push('node-fetch')
        // viteConfig.ssr.optimizeDeps.needsInterop.push('node-fetch')
        'node-fetch': 'interop',

        // passing an object lets you easily apply patches to your actual node_modules
        '@sentry/react-native': {
          // you can specify a semver range to only apply to certain versions:
          version: '~15.2.0',

          // you can use globs to apply to only specific files
          // if you pass an array value, One will apply one of two transforms to matching files:
          //    swc => @swc/core will transform your file into CommonJS compatible code, removing JSX as well
          //    flow => the FlowType transformer will run to remove Flow types
          '**/*.js': ['flow', 'swc']

          // you can also apply custom transforms using a function
          'dist/js/utils/environment.js': (contents) => {
            if (typeof contents !== 'string') return
            return contents.replace(
              `import { version as RNV } from 'react-native/Libraries/Core/ReactNativeVersion';`,
              `import { Platform } from 'react-native';\nconst RNV = Platform.constants.reactNativeVersion;\n`
            )
          },
        },
      },
    })
  ]
} satisfies UserConfig
```

Any transforms that are applied to specific files in node_modules will only be applied once. The original files will be stored alongside the transformed ones.

## router

The router object allows you to configure routing behavior.

### router.ignoredRouteFiles

An array of globs that One uses to ignore files in your routes directory. If a file matches any pattern, it will not be treated as a route.

This is particularly useful for ignoring test files, stories, or other files you want to colocate with your routes but don't want to be treated as actual routes.

```tsx fileName=vite.config.ts
export default {
  plugins: [
    one({
      router: {
        ignoredRouteFiles: [
          '**/*.test.*',
          '**/*.spec.*',
          '**/*.stories.*',
          '**/*.utilities.*',
        ],
      },
    }),
  ],
}
```

**Limitations:** Currently, we only support patterns starting with `**/*`.

### router.experimental.typedRoutesGeneration

Auto-generate route type helpers in your route files. Route types are always generated in `app/routes.d.ts`, but this option controls whether One automatically inserts type helpers into your route files.

```tsx fileName=vite.config.ts
export default {
  plugins: [
    one({
      router: {
        experimental: {
          typedRoutesGeneration: 'runtime', // or 'type' or false
        },
      },
    }),
  ],
}
```

**Options:**

- **`false`** (default): No auto-generation, manually add types yourself
- **`'type'`**: Auto-inserts type-only helpers:

```tsx
import type { RouteType } from 'one'
type Route = RouteType<'/your/[route]'>
```

- **`'runtime'`**: Auto-inserts runtime helpers:

```tsx
import { createRoute } from 'one'
const route = createRoute<'/your/[route]'>()
```

The insertion happens automatically when route files are created or modified, with proper spacing and without modifying your existing code.

For more information, see the [Typed Routes documentation](/docs/routing-typed-routes).

### router.experimental.preventLayoutRemounting

When enabled, the router will try to avoid unnecessary remounts of `_layout` components during navigation.

```tsx fileName=vite.config.ts
export default {
  plugins: [
    one({
      router: {
        experimental: {
          preventLayoutRemounting: true,
        },
      },
    }),
  ],
}
```

This modifies the `<Slot />` navigator to set a static `key` on screen elements, preventing React from remounting them. This is still experimental as it may cause unexpected side effects in some cases.

**Default:** `false`

## ssr

Server-side rendering configuration.

### ssr.autoDepsOptimization

One scans dependencies on startup and decides which ones to optimize based on known problematic dependencies. These include `react-native` and `react`, which need to be optimized to work. It finds all parent dependencies of the known bad deps and adds them to `ssr.optimizeDeps.include`.

```tsx fileName=vite.config.ts
export default {
  plugins: [
    one({
      ssr: {
        // Enable with default include pattern (default)
        autoDepsOptimization: true,

        // Disable entirely
        autoDepsOptimization: false,

        // Configure include/exclude patterns
        autoDepsOptimization: {
          include: /node_modules/,
          exclude: /some-package/,
        },
      },
    }),
  ],
}
```

**Note:** The full path (e.g., `<your_project_path>/node_modules/<some_package>`) is used to match dependencies. If you're using a string to match a package name, you may want to add `*/` at the start and `/*` at the end.

**Default:** `{ include: /node_modules/ }`

## The Environment API

One runs on Vite 6 and makes use of their [new Environment API](https://main.vitejs.dev/guide/api-environment).

This makes it easier to target React Native, as you can specify configuration for iOS, Android and web separately. One defines `ios` and `android` environments, respectively. For web, we follow the Vite standard of having a `client` and `ssr` environments (for client-side and server-side bundles).

You'll want to lean on using the Environment API to configure as much as you can in your `vite.config.ts`. It may also mean that some plugins can cause issues by configuring things across all four environments when you really only want it for client-side, or not. We're working on some helpers to make this easier, but in general you can check for `this.environment.name` in plugin hooks (like `transform` and `load`) to conditionally exit early from their logic for environments where you don't want the plugin logic to run.

One assumes the following environments:

- `client`: Web client-side (matching Vite default)
- `ssr`: Web server-side (matching Vite default)
- `ios`: iOS
- `android`: Android

We set up platform-specific extensions based on the environment:

- client: `.web.(js|ts|tsx|mjs)`
- ssr: `.server.(ts|tsx)`, `.web.(js|ts|tsx|mjs)`
- ios: `.(ios|native).(js|ts|tsx|mjs)`
- android: `.(android|native).(js|ts|tsx|mjs)`

### Server-only files

Files with a `.server.ts` or `.server.tsx` extension are resolved only in the `ssr` environment. This lets you colocate server-only code next to shared code:

```
src/
  db.ts            # shared types/interface
  db.server.ts     # server-only implementation (database queries, secrets, etc.)
```

When you `import './db'` from a server-rendered route or loader, it resolves to `db.server.ts`. On the client or native, it resolves to `db.ts`.

If a `.server.ts` file is explicitly imported on the client or native (e.g. `import './db.server'`), the build will throw an error to prevent server code from leaking into client bundles.

## Other Exports

The `one/vite` import has a few other exports that may be useful.

### `resolvePath`

When you are setting an `alias` in Vite, it wants you to fully specify the import path. We use `resolvePath` to help with this, it's a bit like [`require.resolve`](https://nodejs.org/api/modules.html) that works in ESM or CJS. It's also similar to [`import.meta.resolve`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/import.meta/resolve), except it returns an absolute path that Vite expects rather than a file path.

## Default Configuration

One sets up some default configuration out of the box, including a variety of plugins and settings that make React Native and the ecosystem of packages that are popular "just work".

Some base configuration we set:

- `publicDir` to `"public"`
- `clearScreen` to `false` so we can output the quick actions

We set up `defines`:

- `__DEV__` to true in development mode, or false otherwise
- `process.env.NODE_ENV`

We set up `alias` based on environment:

- `react-native` => `react-native-web` for web environments

We also detect if you have a PostCSS config file (js, ts, or json) and set the `css`. The internal logic is something like:

```tsx
{
  css: postCSSConfigPath
    ? {
        postcss: postCSSConfigPath,
      }
    : {
        transformer: 'lightningcss',
        lightningcss: {
          targets: {
            safari: (15 << 16) | (2 << 8),
          },
        },
      }
}
```
